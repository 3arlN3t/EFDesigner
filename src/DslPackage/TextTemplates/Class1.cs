using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Sawczyn.EFDesigner.EFModel.DslPackage.TextTemplates
{
   class Class1
   {
      public void Run()
      {
         Manager manager = Manager.Create(Host, GenerationEnvironment);
         manager.FileNameMarker = ModelRoot.FileNameMarker;

         if (ModelRoot.Types.OfType<ModelClass>().Any())
         {
            manager.StartHeader(false);
            Output("//------------------------------------------------------------------------------");
            Output("// <auto-generated>");
            Output("//     This code was generated from a template.");
            Output("//");
            Output("//     Manual changes to this file may cause unexpected behavior in your application.");
            Output("//     Manual changes to this file will be overwritten if the code is regenerated.");
            Output("// </auto-generated>");
            Output("//------------------------------------------------------------------------------");
            NL();

            IEFGenerator generator = null;
            switch (ModelRoot.EntityFrameworkVersion)
            {
               case EFVersion.EF6:
                  generator = new EF6Generator(this, manager, this.ModelRoot);
                  break;
               case EFVersion.EFCore:
                  generator = new EFCodeGenerator(this, manager, this.ModelRoot);
                  break;
            }

            if (generator != null)
               generator.Generate();
         }

         manager.Process(true);
      }
   }

   public interface IEFGenerator {
      void Generate();
   }

   public abstract class EFGeneratorBase: IEFGenerator 
   {
      protected static readonly string[] NonNullableTypes = {
         "Binary",
         "Geography",
         "GeographyCollection",
         "GeographyLineString",
         "GeographyMultiLineString",
         "GeographyMultiPoint",
         "GeographyMultiPolygon",
         "GeographyPoint",
         "GeographyPolygon",
         "Geometry",
         "GeometryCollection",
         "GeometryLineString",
         "GeometryMultiLineString",
         "GeometryMultiPoint",
         "GeometryMultiPolygon",
         "GeometryPoint",
         "GeometryPolygon",
         "String"
      };

      protected static readonly string[] SpatialTypes = {
         "Geography",
         "GeographyCollection",
         "GeographyLineString",
         "GeographyMultiLineString",
         "GeographyMultiPoint",
         "GeographyMultiPolygon",
         "GeographyPoint",
         "GeographyPolygon",
         "Geometry",
         "GeometryCollection",
         "GeometryLineString",
         "GeometryMultiLineString",
         "GeometryMultiPoint",
         "GeometryMultiPolygon",
         "GeometryPoint",
         "GeometryPolygon"
      };

      protected Microsoft.VisualStudio.TextTemplating.VSHost.ModelingTextTransformation T4 { get; set; }
      protected Manager OutputManager { get; set; }
      protected ModelRoot Root { get; set; }

      public abstract void Generate();

      protected GeneratorBase(Microsoft.VisualStudio.TextTemplating.VSHost.ModelingTextTransformation t4, Manager manager, ModelRoot modelRoot) {
         T4 = t4;
         OutputManager = manager;
         Root = modelRoot;
      }

      // ******************************************************
      // Info from model
      // ******************************************************

      protected List<string> GetRequiredParameters(ModelClass modelClass, bool? haveDefaults = null)
      {
         List<string> requiredParameters = new List<string>();

         if (haveDefaults != true)
         {
            requiredParameters.AddRange(modelClass.AllRequiredAttributes
               .Where(x => !x.IsIdentity && x.SetterVisibility == SetterAccessModifier.Public && string.IsNullOrEmpty(x.InitialValue))
               .Select(x => $"{x.CLRType} _{x.Name.ToLower()}"));

            requiredParameters.AddRange(modelClass.AllRequiredNavigationProperties()
               .Select(x => $"{x.ClassType.Name} _{x.PropertyName.ToLower().Trim('_')}"));
         }

         if (haveDefaults != false)
         {
            requiredParameters.AddRange(modelClass.AllRequiredAttributes
               .Where(x => !x.IsIdentity && x.SetterVisibility == SetterAccessModifier.Public &&
                           !string.IsNullOrEmpty(x.InitialValue))
               .Select(x =>
               {
                  string quote = x.CLRType == "string" ? "\"" : x.CLRType == "char" ? "'" : "";
                  string value = x.InitialValue.Trim('"', '\'');
                  return $"{x.CLRType} _{x.Name.ToLower()} = {quote}{value}{quote}";
               }));
         }

         return requiredParameters;
      }

      protected List<string> GetRequiredParameterNames(ModelClass modelClass)
      {
         List<string> requiredParameterNames = modelClass.AllRequiredAttributes
            .Where(x => !x.IsIdentity && x.SetterVisibility == SetterAccessModifier.Public &&
                        string.IsNullOrEmpty(x.InitialValue))
            .Select(x => $"_{x.Name.ToLower().Trim('_')}")
            .ToList();

         requiredParameterNames.AddRange(modelClass.AllRequiredNavigationProperties()
            .Select(x => $"_{x.PropertyName.ToLower().Trim('_')}"));

         requiredParameterNames.AddRange(modelClass.AllRequiredAttributes
            .Where(x => !x.IsIdentity && x.SetterVisibility == SetterAccessModifier.Public &&
                        !string.IsNullOrEmpty(x.InitialValue))
            .Select(x => $"_{x.Name.ToLower().Trim('_')}"));

         return requiredParameterNames;
      }

      protected bool IsNullable(ModelAttribute modelAttribute)
      {
         return !modelAttribute.Required &&
                !modelAttribute.IsIdentity &&
                !modelAttribute.IsConcurrencyToken &&
                !NonNullableTypes.Contains(modelAttribute.Type);
      }

      // ******************************************************
      // Wrappers around T4 functionality
      // ******************************************************

      protected void NL()
      {
         T4.WriteLine("");
      }

      protected void Output(string text)
      {
         if (text.StartsWith("}"))
            T4.PopIndent();
         T4.WriteLine(text);
         if (text.EndsWith("{"))
            T4.PushIndent("   ");
      }

      protected void Output(string template, params object[] items)
      {
         string text = string.Format(template, items);
         Output(text);
      }

      protected void OutputChopped(IEnumerable<string> segments)
      {
         if (!segments.Any())
            return;

         string[] segmentArray = segments.ToArray();
         int indent = segmentArray[0].IndexOf('.');

         if (indent == -1)
         {
            if (segmentArray.Length > 1)
            {
               segmentArray[0] = $"{segmentArray[0]}.{segmentArray[1]}";
               indent = segmentArray[0].IndexOf('.');
               segmentArray = segmentArray.Where((source, index) => index != 1).ToArray();
            }
         }

         for (int index = 1; index < segmentArray.Length; ++index)
            segmentArray[index] = $"{new string(' ', indent)}.{segmentArray[index]}";

         if (!segmentArray[segmentArray.Length - 1].Trim().EndsWith(";"))
            segmentArray[segmentArray.Length - 1] = segmentArray[segmentArray.Length - 1] + ";";

         foreach (string segment in segmentArray)
            Output(segment);
      }

      protected void BeginNamespace(string ns)
      {
         if (!string.IsNullOrEmpty(ns))
         {
            Output($"namespace {ns}");
            Output("{");
         }
      }

      protected void EndNamespace(string ns)
      {
         if (!string.IsNullOrEmpty(ns))
            Output("}");
      }

   }

   public class EF6Generator : EFGeneratorBase
   {
      public EF6Generator(Microsoft.VisualStudio.TextTemplating.VSHost.ModelingTextTransformation t4, Manager manager, ModelRoot modelRoot)
         : base(t4, manager, modelRoot)
      {
      }

      public override void Generate()
      {
         // Entities

         foreach (ModelClass modelClass in Root.Types.OfType<ModelClass>())
         {
            OutputManager.StartNewFile(Path.Combine(Root.EntityOutputDirectory, $"{modelClass.Name}.{Root.FileNameMarker}.cs"));
            Output("using System;");
            Output("using System.Collections.Generic;");
            Output("using System.Collections.ObjectModel;");
            Output("using System.Linq;");
            List<string> additionalUsings = GetAdditionalUsingStatements();
            if (additionalUsings.Any())
               Output(string.Join("\n", additionalUsings));
            NL();

            BeginNamespace(modelClass.Namespace);

            string baseClass = modelClass.Superclass != null ? $" : {modelClass.Superclass.Name}" : string.Empty;
            string isAbstract = modelClass.IsAbstract ? "abstract " : "";
            Output($"public {isAbstract}partial class {modelClass.Name}{baseClass}");
            Output("{");

            WriteConstructor(modelClass);
            WritePersistentProperties(modelClass);
            WriteCalculatedProperties(modelClass);
            WritePersistentNavigationProperties(modelClass);
            WriteCalculatedNavigationProperties(modelClass);

            Output("}");

            EndNamespace(modelClass.Namespace);
            NL();
         }

         // Enums

         foreach (ModelEnum modelEnum in Root.Enums)
         {
            OutputManager.StartNewFile(Path.Combine(Root.EnumOutputDirectory, $"{modelEnum.Name}.{Root.FileNameMarker}.cs"));

            Output("using System;");
            NL();

            BeginNamespace(modelEnum.Namespace);

            Output($"public enum {modelEnum.Name} : {modelEnum.ValueType}");
            Output("{");

            ModelEnumValue[] values = modelEnum.Values.ToArray();
            for (int index = 0; index < values.Length; ++index)
            {
               if (string.IsNullOrEmpty(values[index].Value))
                  Output($"{values[index].Name}{(index < values.Length - 1 ? "," : "")}");
               else
                  Output($"{values[index].Name} = {values[index].Value}{(index < values.Length - 1 ? "," : "")}");
            }
            Output("}");

            EndNamespace(modelEnum.Namespace);
         }

         OutputManager.StartNewFile(Path.Combine(Root.ContextOutputDirectory, $"{Root.EntityContainerName}DatabaseInitializer.{Root.FileNameMarker}.cs"));
         WriteDatabaseInitializer(Root);

         OutputManager.StartNewFile(Path.Combine(Root.ContextOutputDirectory, $"{Root.EntityContainerName}DbMigrationConfiguration.{Root.FileNameMarker}.cs"));
         WriteMigrationConfiguration(Root);

         OutputManager.StartNewFile(Path.Combine(Root.ContextOutputDirectory, $"{Root.EntityContainerName}.{Root.FileNameMarker}.cs"));
         WriteDbContext(Root);
      }

      private List<string> GetAdditionalUsingStatements()
      {
         List<string> result = new List<string>();
         List<string> attributeTypes = Root.Types.OfType<ModelClass>().SelectMany(c => c.Attributes).Select(a => a.Type).Distinct().ToList();

         if (attributeTypes.Any(t => t.IndexOf("Geometry", StringComparison.Ordinal) > -1 || t.IndexOf("Geography", StringComparison.Ordinal) > -1))
         {
            result.Add("using System.Data.Entity.Spatial;");
         }

         return result;
      }

      private void WriteDefaultConstructorBody(ModelClass modelClass)
      {
         foreach (ModelAttribute modelAttribute in modelClass.Attributes.Where(x => x.SetterVisibility == SetterAccessModifier.Public &&
                                                                                    !string.IsNullOrEmpty(x.InitialValue) &&
                                                                                    x.InitialValue != "null"))
         {
            string quote = modelAttribute.Type == "String" ? "\"" : modelAttribute.Type == "Char" ? "'" : "";
            Output($"{modelAttribute.Name} = {quote}{modelAttribute.InitialValue}{quote};");
         }

         foreach (NavigationProperty navigationProperty in modelClass.LocalNavigationProperties().Where(x => x.AssociationObject.Persistent && x.IsCollection && !x.ConstructorParameterOnly))
            Output($"{navigationProperty.PropertyName} = new {navigationProperty.AssociationObject.CollectionClass}<{navigationProperty.ClassType.Name}>();");

         NL();
         Output("Init();");
      }

      private void WriteConstructor(ModelClass modelClass)
      {
         Output("partial void Init();");
         NL();

         /***********************************************************************/
         // Default constructor
         /***********************************************************************/

         string visibility = GetRequiredParameters(modelClass, false).Any() ? "protected" : "public";

         if (visibility == "public")
         {
            Output("/// <summary>");
            Output("/// Default constructor");
            Output("/// </summary>");
         }
         else
         {
            Output("/// <summary>");
            Output("/// Default constructor. Protected due to required properties, but present because EF needs it.");
            Output("/// </summary>");
         }

         if (modelClass.Superclass != null)
            Output($"{visibility} {modelClass.Name}(): base()");
         else
            Output($"{visibility} {modelClass.Name}()");
         Output("{");

         WriteDefaultConstructorBody(modelClass);

         Output("}");
         NL();

         /***********************************************************************/
         // Constructor with required parameters (if necessary)
         /***********************************************************************/

         if (visibility == "protected")
         {
            Output("/// <summary>");
            Output("/// Public constructor with required data");
            Output("/// </summary>");
            WriteConstructorComments(modelClass);
            Output($"public {modelClass.Name}({string.Join(", ", GetRequiredParameters(modelClass))})");
            Output("{");

            foreach (ModelAttribute requiredAttribute in modelClass.AllRequiredAttributes.Where(x => !x.IsIdentity && x.SetterVisibility == SetterAccessModifier.Public))
            {
               if (requiredAttribute.Type == "String")
                  Output($"if (string.IsNullOrEmpty(_{requiredAttribute.Name.ToLower().Trim('_')})) throw new ArgumentNullException(nameof(_{requiredAttribute.Name.ToLower().Trim('_')}));");
               else if (requiredAttribute.Type.StartsWith("Geo"))
                  Output($"if (_{requiredAttribute.Name.ToLower().Trim('_')} == null) throw new ArgumentNullException(nameof(_{requiredAttribute.Name.ToLower().Trim('_')}));");
               Output($"{requiredAttribute.Name} = _{requiredAttribute.Name.ToLower().Trim('_')};");
            }

            foreach (NavigationProperty requiredNavigationProperty in modelClass.AllRequiredNavigationProperties())
            {
               string parameterName = requiredNavigationProperty.PropertyName.ToLower().Trim('_');
               Output($"if (_{parameterName} == null) throw new ArgumentNullException(nameof(_{parameterName}));");

               if (requiredNavigationProperty.IsCollection)
                  Output($"{requiredNavigationProperty.PropertyName}.Add(_{parameterName});");
               else if (requiredNavigationProperty.ConstructorParameterOnly)
               {
                  UnidirectionalAssociation association = requiredNavigationProperty.AssociationObject as UnidirectionalAssociation;
                  if (association.TargetMultiplicity == Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroMany)
                     Output($"{requiredNavigationProperty.PropertyName}.{association.TargetPropertyName}.Add(this);");
                  else
                     Output($"{requiredNavigationProperty.PropertyName}.{association.TargetPropertyName} = this;");
               }
               else
                  Output($"{requiredNavigationProperty.PropertyName} = _{parameterName};");

               NL();
            }

            foreach (NavigationProperty navigationProperty in modelClass.LocalNavigationProperties().Where(x => x.AssociationObject.Persistent && x.IsCollection && !x.ConstructorParameterOnly))
               Output($"{navigationProperty.PropertyName} = new {navigationProperty.AssociationObject.CollectionClass}<{navigationProperty.ClassType.Name}>();");

            Output("}");
            NL();


            Output("/// <summary>");
            Output("/// Static create function (for use in LINQ queries, etc.)");
            Output("/// </summary>");
            WriteConstructorComments(modelClass);
            Output($"public static {modelClass.Name} Create({string.Join(", ", GetRequiredParameters(modelClass))})");
            Output("{");
            Output($"return new {modelClass.Name}({string.Join(", ", GetRequiredParameterNames(modelClass))});");
            Output("}");
            NL();


         }
      }

      private void WriteConstructorComments(ModelClass modelClass)
      {
         foreach (ModelAttribute requiredAttribute in modelClass.AllRequiredAttributes.Where(x => !x.IsIdentity && x.SetterVisibility == SetterAccessModifier.Public))
            Output($@"/// <param name=""_{requiredAttribute.Name.ToLower().Trim('_')}"">{requiredAttribute.Summary}</param>");
         // TODO: Add comment if available
         foreach (NavigationProperty requiredNavigationProperty in modelClass.AllRequiredNavigationProperties())
            Output($@"/// <param name=""_{requiredNavigationProperty.PropertyName.ToLower().Trim('_')}""></param>");
      }

      private void WritePersistentProperties(ModelClass modelClass)
      {
         if (!modelClass.Attributes.Any(x => x.Persistent))
            return;

         Output("// Persistent properties");
         List<string> segments = new List<string>();
         NL();

         foreach (ModelAttribute modelAttribute in modelClass.Attributes.Where(x => x.Persistent))
         {
            segments.Clear();

            if (modelAttribute.IsIdentity)
               segments.Add("Identity");
            if (modelAttribute.Required || modelAttribute.IsIdentity)
               segments.Add("Required");
            if (modelAttribute.Indexed)
               segments.Add("Indexed");
            if (modelAttribute.MaxLength > 0)
               segments.Add($"Max length = {modelAttribute.MaxLength}");
            if (!string.IsNullOrEmpty(modelAttribute.InitialValue))
            {
               string quote = modelAttribute.CLRType == "string" ? "\"" : modelAttribute.CLRType == "char" ? "'" : "";
               segments.Add($"Default value = {quote}{modelAttribute.InitialValue}{quote}");
            }

            string nullable = IsNullable(modelAttribute) ? "?" : "";

            if (!modelAttribute.AutoProperty)
            {
               Output($"private {modelAttribute.CLRType}{nullable} _{modelAttribute.Name};");
               Output($"partial void Set{modelAttribute.Name}({modelAttribute.CLRType}{nullable} oldValue, ref {modelAttribute.CLRType}{nullable} newValue);");
               Output($"partial void Get{modelAttribute.Name}(ref {modelAttribute.CLRType}{nullable} result);");
               NL();
            }

            if (!string.IsNullOrEmpty(modelAttribute.Summary) || segments.Any())
            {
               Output("/// <summary>");
               if (segments.Any())
                  Output($"/// {string.Join(", ", segments)}");
               if (!string.IsNullOrEmpty(modelAttribute.Summary))
                  Output("/// {0}", modelAttribute.Summary);
               Output("/// </summary>");
            }

            string setterVisibility = modelAttribute.SetterVisibility == SetterAccessModifier.Protected ? "protected " : modelAttribute.SetterVisibility == SetterAccessModifier.Internal ? "internal " : "";

            if (modelAttribute.AutoProperty)
               Output($"public {modelAttribute.CLRType}{nullable} {modelAttribute.Name} {{ get; {setterVisibility}set; }}");
            else
            {
               Output($"public {modelAttribute.CLRType}{nullable} {modelAttribute.Name}");
               Output("{");
               Output($"get {{ {modelAttribute.CLRType}{nullable} value = _{modelAttribute.Name}; Get{modelAttribute.Name}(ref value); return (_{modelAttribute.Name} = value); }}");
               Output($"{setterVisibility}set {{ {modelAttribute.CLRType}{nullable} oldValue = _{modelAttribute.Name}; Set{modelAttribute.Name}(oldValue, ref value); _{modelAttribute.Name} = value; }}");
               Output("}");
            }

            NL();
         }

         if (!modelClass.AllAttributes.Any(x => x.IsConcurrencyToken) &&
             (modelClass.Concurrency == ConcurrencyOverride.Optimistic || modelClass.ModelRoot.ConcurrencyDefault == Concurrency.Optimistic))
         {
            Output("/// <summary>");
            Output("/// Concurrency token");
            Output("/// </summary>");
            Output("public DateTime Timestamp { get; set; }");
            NL();
         }
      }

      private void WriteCalculatedProperties(ModelClass modelClass)
      {
         if (modelClass.Attributes.All(x => x.Persistent))
            return;

         Output("// Calculated properties");
         NL();

         foreach (ModelAttribute calculatedAttribute in modelClass.Attributes.Where(x => !x.Persistent))
         {
            string nullable = IsNullable(calculatedAttribute) ? "?" : "";

            Output("partial void Get{0}(ref {1}{2} value);", calculatedAttribute.Name, calculatedAttribute.CLRType, nullable);
            Output("partial void Set{0}({1}{2} value);", calculatedAttribute.Name, calculatedAttribute.CLRType, nullable);

            Output("/// <summary>");
            Output("/// Calculated property");
            if (!string.IsNullOrEmpty(calculatedAttribute.Summary))
               Output("/// {0}", calculatedAttribute.Summary);
            Output("/// </summary>");

            if (!string.IsNullOrEmpty(calculatedAttribute.Description))
            {
               Output("/// <remarks>");
               Output("/// {0}", calculatedAttribute.Description);
               Output("/// </remarks>");
            }

            string setterVisibility = calculatedAttribute.SetterVisibility == SetterAccessModifier.Protected ? "protected " : calculatedAttribute.SetterVisibility == SetterAccessModifier.Internal ? "internal " : "";
            string isVirtual = calculatedAttribute.Virtual ? "virtual " : "";

            Output($"public {isVirtual}{calculatedAttribute.CLRType}{nullable} {calculatedAttribute.Name}");
            Output("{");
            Output($"get {{ {calculatedAttribute.CLRType}{nullable} value = default({calculatedAttribute.CLRType}{nullable}); Get{calculatedAttribute.Name}(ref value); return value; }}");
            Output($"{setterVisibility}set {{ Set{calculatedAttribute.Name}(value); }}");
            Output("}");
            NL();
         }
      }

      private void WritePersistentNavigationProperties(ModelClass modelClass)
      {
         if (!modelClass.LocalNavigationProperties().Any(x => x.AssociationObject.Persistent))
            return;

         Output("// Persistent navigation properties");
         NL();

         foreach (NavigationProperty navigationProperty in modelClass.LocalNavigationProperties().Where(x => x.AssociationObject.Persistent && !x.ConstructorParameterOnly))
         {
            string type = navigationProperty.IsCollection
                              ? $"ICollection<{navigationProperty.ClassType.Name}>"
                              : navigationProperty.ClassType.Name;

            List<string> comments = new List<string>();
            if (navigationProperty.Required)
               comments.Add("Required");
            string comment = comments.Count > 0 ? $" // {string.Join(", ", comments)}" : "";

            Output($"public virtual {type} {navigationProperty.PropertyName} {{ get; set; }} {comment}");
         }
      }

      private void WriteCalculatedNavigationProperties(ModelClass modelClass)
      {
         if (modelClass.LocalNavigationProperties().All(x => x.AssociationObject.Persistent))
            return;

         Output("// Calculated navigation properties");
         NL();

         foreach (NavigationProperty navigationProperty in modelClass.LocalNavigationProperties().Where(x => !x.AssociationObject.Persistent && !x.ConstructorParameterOnly))
         {
            string type = navigationProperty.IsCollection
                              ? $"ICollection<{navigationProperty.ClassType.Name}>"
                              : navigationProperty.ClassType.Name;

            Output($"partial void Get{navigationProperty.PropertyName}(ref {type} value);");
            Output($"partial void Set{navigationProperty.PropertyName}({type} value);");

            Output($"public {type} {navigationProperty.PropertyName}");
            Output("{");
            Output($"get {{ {type} value = null; Get{navigationProperty.PropertyName}(ref value); return value; }}");
            Output($"set {{ Set{navigationProperty.PropertyName}(value); }}");
            Output("}");
            NL();
         }
      }

      private void WriteDatabaseInitializer()
      {
         Output("using System.Data.Entity;");
         NL();

         BeginNamespace(Root.Namespace);

         if (Root.DatabaseInitializerType == DatabaseInitializerKind.MigrateDatabaseToLatestVersion)
            Output($"public partial class {Root.EntityContainerName}DatabaseInitializer : MigrateDatabaseToLatestVersion<{Root.EntityContainerName}, {Root.EntityContainerName}DbMigrationConfiguration>");
         else
            Output($"public partial class {Root.EntityContainerName}DatabaseInitializer : {Root.DatabaseInitializerType}<{Root.EntityContainerName}>");

         Output("{");
         Output("}");
         EndNamespace(Root.Namespace);
      }

      private void WriteMigrationConfiguration()
      {
         //if (modelRoot.DatabaseInitializerType != DatabaseInitializerKind.MigrateDatabaseToLatestVersion)
         //   return;

         Output("using System.Data.Entity.Migrations;");
         NL();

         BeginNamespace(Root.Namespace);
         Output("public sealed partial class {0}DbMigrationConfiguration : DbMigrationsConfiguration<{0}>", Root.EntityContainerName);

         Output("{");
         Output("partial void Init();");
         NL();

         Output("public {0}DbMigrationConfiguration()", Root.EntityContainerName);
         Output("{");
         Output("AutomaticMigrationsEnabled = {0};", Root.AutomaticMigrationsEnabled.ToString().ToLower());
         Output("AutomaticMigrationDataLossAllowed = false;");
         Output("Init();");
         Output("}");

         Output("}");
         EndNamespace(Root.Namespace);
      }

      private void WriteDbContext()
      {
         Output("using System;");
         Output("using System.Collections.Generic;");
         Output("using System.Linq;");
         Output("using System.ComponentModel.DataAnnotations.Schema;");
         Output("using System.Data.Entity.Infrastructure.Annotations;");
         NL();

         BeginNamespace(modelRoot.Namespace);

         Output($"{modelRoot.EntityContainerAccess.ToString().ToLower()} partial class {modelRoot.EntityContainerName} : System.Data.Entity.DbContext");
         Output("{");

         PluralizationService pluralizationService = PluralizationService.CreateService(CultureInfo.CurrentCulture);

         /***********************************************************************/
         // generate DBSets
         /***********************************************************************/

         IEnumerable<ModelClass> classesWithTables = null;

         switch (modelRoot.InheritanceStrategy)
         {
            case CodeStrategy.TablePerType:
               classesWithTables = modelRoot.Types.OfType<ModelClass>().OrderBy(x => x.Name);
               break;
            case CodeStrategy.TablePerConcreteType:
               classesWithTables = modelRoot.Types.OfType<ModelClass>().Where(mc => !mc.IsAbstract).OrderBy(x => x.Name);
               break;
            case CodeStrategy.TablePerHierarchy:
               classesWithTables = modelRoot.Types.OfType<ModelClass>().Where(x => x.Superclass == null).OrderBy(x => x.Name);
               break;
         }

         if (classesWithTables != null)
         {
            foreach (ModelClass modelClass in classesWithTables)
            {
               string dbSetName;

               if (!string.IsNullOrEmpty(modelClass.DbSetName))
                  dbSetName = modelClass.DbSetName;
               else
                  dbSetName = pluralizationService.IsSingular(modelClass.Name)
                     ? pluralizationService.Pluralize(modelClass.Name)
                     : modelClass.Name;

               Output($"public System.Data.Entity.DbSet<{modelClass.Name}> {dbSetName} {{ get; set; }}");
            }

            NL();
         }

         /***********************************************************************/
         // constructors
         /***********************************************************************/

         if (!string.IsNullOrEmpty(modelRoot.ConnectionString) || !string.IsNullOrEmpty(modelRoot.ConnectionStringName))
         {
            string connectionString = string.IsNullOrEmpty(modelRoot.ConnectionString)
                                         ? $"Name={modelRoot.ConnectionStringName}"
                                         : modelRoot.ConnectionString;

            Output($"public {modelRoot.EntityContainerName}() : base(@\"{connectionString}\")");
            Output("{");
            Output($"Configuration.LazyLoadingEnabled = {modelRoot.LazyLoadingEnabled.ToString().ToLower()};");
            Output($"Configuration.ProxyCreationEnabled = {modelRoot.ProxyGenerationEnabled.ToString().ToLower()};");
            Output($"System.Data.Entity.Database.SetInitializer(new {modelRoot.EntityContainerName}DatabaseInitializer());");
            Output("CustomInit();");
            Output("}");
            NL();
         }
         else
         {
            Output($"#warning Default constructor not generated for {modelRoot.EntityContainerName} since no default connection string was specified in the model");
            NL();
         }

         Output($"public {modelRoot.EntityContainerName}(string connectionString) : base(connectionString)");
         Output("{");
         Output($"Configuration.LazyLoadingEnabled = {modelRoot.LazyLoadingEnabled.ToString().ToLower()};");
         Output($"Configuration.ProxyCreationEnabled = {modelRoot.ProxyGenerationEnabled.ToString().ToLower()};");
         Output($"System.Data.Entity.Database.SetInitializer(new {modelRoot.EntityContainerName}DatabaseInitializer());");
         Output("CustomInit();");
         Output("}");
         NL();

         Output($"public {modelRoot.EntityContainerName}(string connectionString, System.Data.Entity.Infrastructure.DbCompiledModel model) : base(connectionString, model)");
         Output("{");
         Output($"Configuration.LazyLoadingEnabled = {modelRoot.LazyLoadingEnabled.ToString().ToLower()};");
         Output($"Configuration.ProxyCreationEnabled = {modelRoot.ProxyGenerationEnabled.ToString().ToLower()};");
         Output($"System.Data.Entity.Database.SetInitializer(new {modelRoot.EntityContainerName}DatabaseInitializer());");
         Output("CustomInit();");
         Output("}");
         NL();

         Output($"public {modelRoot.EntityContainerName}(System.Data.Common.DbConnection existingConnection, bool contextOwnsConnection) : base(existingConnection, contextOwnsConnection)");
         Output("{");
         Output($"Configuration.LazyLoadingEnabled = {modelRoot.LazyLoadingEnabled.ToString().ToLower()};");
         Output($"Configuration.ProxyCreationEnabled = {modelRoot.ProxyGenerationEnabled.ToString().ToLower()};");
         Output($"System.Data.Entity.Database.SetInitializer(new {modelRoot.EntityContainerName}DatabaseInitializer());");
         Output("CustomInit();");
         Output("}");
         NL();

         Output($"public {modelRoot.EntityContainerName}(System.Data.Common.DbConnection existingConnection, System.Data.Entity.Infrastructure.DbCompiledModel model, bool contextOwnsConnection) : base(existingConnection, model, contextOwnsConnection)");
         Output("{");
         Output($"Configuration.LazyLoadingEnabled = {modelRoot.LazyLoadingEnabled.ToString().ToLower()};");
         Output($"Configuration.ProxyCreationEnabled = {modelRoot.ProxyGenerationEnabled.ToString().ToLower()};");
         Output($"System.Data.Entity.Database.SetInitializer(new {modelRoot.EntityContainerName}DatabaseInitializer());");
         Output("CustomInit();");
         Output("}");
         NL();

         Output("partial void CustomInit();");
         Output("partial void OnModelCreatingImpl(System.Data.Entity.DbModelBuilder modelBuilder);");
         Output("partial void OnModelCreatedImpl(System.Data.Entity.DbModelBuilder modelBuilder);");
         NL();

         /***********************************************************************/
         // OnModelCreating 
         /***********************************************************************/
         Output("protected override void OnModelCreating(System.Data.Entity.DbModelBuilder modelBuilder)");
         Output("{");
         Output("base.OnModelCreating(modelBuilder);");
         Output("OnModelCreatingImpl(modelBuilder);");
         NL();

         Output($"modelBuilder.HasDefaultSchema(\"{modelRoot.DatabaseSchema}\");");

         List<string> segments = new List<string>();

         Sawczyn.EFDesigner.EFModel.Multiplicity[] singles = { Sawczyn.EFDesigner.EFModel.Multiplicity.One, Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroOne };
         Sawczyn.EFDesigner.EFModel.Multiplicity[] multiples = { Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroMany };
         List<Association> visited = new List<Association>();
         List<string> foreignKeyColumns = new List<string>();

         foreach (ModelClass modelClass in modelRoot.Types.OfType<ModelClass>().OrderBy(x => x.Name))
         {
            segments.Clear();
            foreignKeyColumns.Clear();
            NL();

            // class level
            segments.Add($"modelBuilder.Entity<{modelClass.Name}>()");

            // note: this must come before the 'ToTable' call or there's a runtime error
            if (modelRoot.InheritanceStrategy == CodeStrategy.TablePerConcreteType && modelClass.Superclass != null)
               segments.Add("Map(x => x.MapInheritedProperties())");

            if (classesWithTables.Contains(modelClass))
            {
               if (modelClass.DatabaseSchema == modelClass.ModelRoot.DatabaseSchema)
                  segments.Add($"ToTable(\"{modelClass.TableName}\")");
               else
                  segments.Add($"ToTable(\"{modelClass.TableName}\", \"{modelClass.DatabaseSchema}\")");
            }

            List<string> identityProperties = modelClass.IdentityPropertyNames.ToList();
            if (identityProperties.Count == 1)
               segments.Add($"HasKey(t => t.{identityProperties[0]})");
            else
               segments.Add($"HasKey(t => new {{ t.{string.Join(", t.", identityProperties)} }})");

            foreach (ModelAttribute transient in modelClass.Attributes.Where(x => !x.Persistent))
               segments.Add($"Ignore(t => t.{transient.Name})");

            if (modelRoot.ChopMethodChains)
               OutputChopped(segments);
            else
               Output(string.Join(".", segments) + ";");

            // attribute level
            foreach (ModelAttribute modelAttribute in modelClass.Attributes.Where(x => x.Persistent && !SpatialTypes.Contains(x.Type)))
            {
               segments.Clear();

               if (modelAttribute.MaxLength > 0)
                  segments.Add($"HasMaxLength({modelAttribute.MaxLength})");
               if (modelAttribute.Required)
                  segments.Add("IsRequired()");
               if (modelAttribute.Indexed)
                  segments.Add("HasColumnAnnotation(\"Index\", new IndexAnnotation(new IndexAttribute()))");
               if (modelAttribute.IsConcurrencyToken)
                  segments.Add("IsRowVersion()");
               if (modelAttribute.IsIdentity)
                  segments.Add("HasDatabaseGeneratedOption(DatabaseGeneratedOption.Identity)");

               if (segments.Any())
               {
                  segments.Insert(0, $"modelBuilder.Entity<{modelClass.Name}>()");
                  segments.Insert(1, $"Property(t => t.{modelAttribute.Name})");

                  if (modelRoot.ChopMethodChains)
                     OutputChopped(segments);
                  else
                     Output(string.Join(".", segments) + ";");
               }
            }

            // Navigation endpoints are distingished as Source and Target. They are also distinguished as Principal
            // and Dependent. How do these map?
            // In the case of one-to-one or zero-to-one-to-zero-to-one, it's model dependent and the user has to tell us
            // In all other cases, we can tell by the cardinalities of the associations
            // What matters is the Principal and Dependent classifications, so we look at those. 
            // Source and Target are accidents of where the user started drawing the association.

            // navigation properties
            foreach (UnidirectionalAssociation association in Association.GetLinksToTargets(modelClass).OfType<UnidirectionalAssociation>())
            {
               if (visited.Contains(association)) continue;
               visited.Add(association);

               // Certain associations cascade delete automatically. Also, the user may ask for it.
               // We only generate a cascade delete call if the user asks for it. EF will handle the rest automatically, and it can
               // cause issues if we make the call when it's not needed.
               bool cascadeDelete = association.TargetDeleteAction != DeleteAction.None;

               segments.Clear();
               segments.Add($"modelBuilder.Entity<{modelClass.Name}>()");

               switch (association.TargetMultiplicity) // realized by property on source
               {
                  case Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroMany:
                     segments.Add($"HasMany(x => x.{association.TargetPropertyName})");
                     break;
                  case Sawczyn.EFDesigner.EFModel.Multiplicity.One:
                     segments.Add($"HasRequired(x => x.{association.TargetPropertyName})");
                     cascadeDelete = true;
                     break;
                  case Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroOne:
                     segments.Add($"HasOptional(x => x.{association.TargetPropertyName})");
                     break;
                     //case Sawczyn.EFDesigner.EFModel.Multiplicity.OneMany:
                     //   segments.Add($"HasMany(x => x.{association.TargetPropertyName})");
                     //   break;
               }

               switch (association.SourceMultiplicity) // realized by property on target, but no property on target
               {
                  case Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroMany:
                     segments.Add("WithMany()");
                     if (association.TargetMultiplicity == Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroMany)
                     {
                        segments.Add("Map(x => { " +
                           $@"x.ToTable(""{association.Source.Name}_x_{association.TargetPropertyName}""); " +
                           $@"x.MapLeftKey(""{association.Source.Name}_{association.Source.AllAttributes.FirstOrDefault(a => a.IsIdentity)?.Name}""); " +
                           $@"x.MapRightKey(""{association.Target.Name}_{association.Target.AllAttributes.FirstOrDefault(a => a.IsIdentity)?.Name}""); " +
                           "})");
                     }
                     break;
                  case Sawczyn.EFDesigner.EFModel.Multiplicity.One:
                     if (association.TargetMultiplicity == Sawczyn.EFDesigner.EFModel.Multiplicity.One)
                     {
                        if (association.TargetRole == EndpointRole.Dependent)
                           segments.Add("WithRequiredDependent()");
                        else
                           segments.Add("WithRequiredPrincipal()");
                     }
                     else
                     {
                        segments.Add("WithRequired()");
                     }

                     cascadeDelete = true;
                     break;
                  case Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroOne:
                     if (association.TargetMultiplicity == Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroOne)
                     {
                        if (association.TargetRole == EndpointRole.Dependent)
                           segments.Add("WithOptionalDependent()");
                        else
                           segments.Add("WithOptionalPrincipal()");
                     }
                     else
                     {
                        segments.Add("WithOptional()");
                     }

                     break;
                     //case Sawczyn.EFDesigner.EFModel.Multiplicity.OneMany:
                     //   segments.Add("HasMany()");
                     //   break;
               }

               string foreignKeySegment = CreateForeignKeyColumnSegment(association, foreignKeyColumns);
               if (foreignKeySegment != null) segments.Add(foreignKeySegment);

               if (cascadeDelete)
                  segments.Add("WillCascadeOnDelete()");

               if (modelRoot.ChopMethodChains)
                  OutputChopped(segments);
               else
                  Output(string.Join(".", segments) + ";");
            }

            foreach (BidirectionalAssociation association in Association.GetLinksToSources(modelClass).OfType<BidirectionalAssociation>())
            {
               if (visited.Contains(association)) continue;
               visited.Add(association);

               // TODO: fix cascade delete
               bool cascadeDelete = association.SourceDeleteAction != DeleteAction.None;

               segments.Clear();
               segments.Add($"modelBuilder.Entity<{modelClass.Name}>()");

               switch (association.SourceMultiplicity) // realized by property on target
               {
                  case Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroMany:
                     segments.Add($"HasMany(x => x.{association.SourcePropertyName})");
                     break;
                  case Sawczyn.EFDesigner.EFModel.Multiplicity.One:
                     segments.Add($"HasRequired(x => x.{association.SourcePropertyName})");
                     cascadeDelete = true;
                     break;
                  case Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroOne:
                     segments.Add($"HasOptional(x => x.{association.SourcePropertyName})");
                     break;
                     //one or more constraint not supported in EF6. TODO: make this possible ... later
                     //case Sawczyn.EFDesigner.EFModel.Multiplicity.OneMany:
                     //   segments.Add($"HasMany(x => x.{association.SourcePropertyName})");
                     //   break;
               }

               switch (association.TargetMultiplicity) // realized by property on source
               {
                  case Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroMany:
                     segments.Add($"WithMany(x => x.{association.TargetPropertyName})");
                     if (association.SourceMultiplicity == Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroMany)
                     {
                        segments.Add("Map(x => { " +
                           $@"x.ToTable(""{association.SourcePropertyName}_x_{association.TargetPropertyName}""); " +
                           $@"x.MapLeftKey(""{association.Source.Name}_{association.Source.AllAttributes.FirstOrDefault(a => a.IsIdentity)?.Name}""); " +
                           $@"x.MapRightKey(""{association.Target.Name}_{association.Target.AllAttributes.FirstOrDefault(a => a.IsIdentity)?.Name}""); " +
                           "})");
                     }
                     break;
                  case Sawczyn.EFDesigner.EFModel.Multiplicity.One:
                     if (association.SourceMultiplicity == Sawczyn.EFDesigner.EFModel.Multiplicity.One)
                     {
                        if (association.SourceRole == EndpointRole.Dependent)
                           segments.Add($"WithRequiredDependent(x => x.{association.TargetPropertyName})");
                        else
                           segments.Add($"WithRequiredPrincipal(x => x.{association.TargetPropertyName})");
                     }
                     else
                     {
                        segments.Add($"WithRequired(x => x.{association.TargetPropertyName})");
                     }

                     cascadeDelete = true;
                     break;
                  case Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroOne:
                     if (association.SourceMultiplicity == Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroOne)
                     {
                        if (association.SourceRole == EndpointRole.Dependent)
                           segments.Add($"WithOptionalDependent(x => x.{association.TargetPropertyName})");
                        else
                           segments.Add($"WithOptionalPrincipal(x => x.{association.TargetPropertyName})");
                     }
                     else
                     {
                        segments.Add($"WithOptional(x => x.{association.TargetPropertyName})");
                     }

                     break;
                     //one or more constraint not supported in EF6. TODO: make this possible ... later
                     //case Sawczyn.EFDesigner.EFModel.Multiplicity.OneMany:
                     //   segments.Add($"HasMany(x => x.{association.TargetPropertyName})");
                     //   break;
               }

               string foreignKeySegment = CreateForeignKeyColumnSegment(association, foreignKeyColumns);
               if (foreignKeySegment != null) segments.Add(foreignKeySegment);

               if (cascadeDelete)
                  segments.Add("WillCascadeOnDelete()");

               if (modelRoot.ChopMethodChains)
                  OutputChopped(segments);
               else
                  Output(string.Join(".", segments) + ";");
            }
         }

         NL();

         Output("OnModelCreatedImpl(modelBuilder);");
         Output("}");

         Output("}");

         EndNamespace(modelRoot.Namespace);
      }

      private string CreateForeignKeyColumnSegment(Association association, List<string> foreignKeyColumns)
      {
         // foreign key definitions always go in the table representing the Dependent end of the association
         // if there is no dependent end (i.e., many-to-many), there are no foreign keys
         string nameBase = string.Empty;
         if (association.SourceRole == EndpointRole.Dependent)
            nameBase = association.TargetPropertyName;
         else if (association.TargetRole == EndpointRole.Dependent)
            nameBase = (association as BidirectionalAssociation)?.SourcePropertyName ?? association.Source.Name;
         else
            return null;

         string columnName = $"{nameBase}_Id";
         if (foreignKeyColumns.Contains(columnName))
         {
            int index = 0;
            do
            {
               columnName = $"{nameBase}{++index}_Id";
            } while (foreignKeyColumns.Contains(columnName));
         }
         foreignKeyColumns.Add(columnName);
         return $@"Map(x => x.MapKey(""{columnName}""))";
      }
   }

   public class EFCoreGenerator: EFGeneratorBase
   {
      public EFCoreGenerator(Microsoft.VisualStudio.TextTemplating.VSHost.ModelingTextTransformation t4, Manager manager, ModelRoot modelRoot)
         : base(t4, manager, modelRoot)
      {
      }

      public override void Generate()
      {
         // Entities

         foreach (ModelClass modelClass in Root.Types.OfType<ModelClass>())
         {
            manager.StartNewFile(Path.Combine(modelRoot.EntityOutputDirectory, $"{modelClass.Name}.{modelRoot.FileNameMarker}.cs"));
            Output("using System;");
            Output("using System.Collections.Generic;");
            Output("using System.Collections.ObjectModel;");
            Output("using System.Linq;");
            List<string> additionalUsings = GetAdditionalUsingStatements(modelRoot);
            if (additionalUsings.Any())
               Output(string.Join("\n", additionalUsings));
            NL();

            BeginNamespace(modelClass.Namespace);

            string baseClass = modelClass.Superclass != null ? $" : {modelClass.Superclass.Name}" : string.Empty;
            string isAbstract = modelClass.IsAbstract ? "abstract " : "";
            Output($"public {isAbstract}partial class {modelClass.Name}{baseClass}");
            Output("{");

            WriteConstructor(modelClass);
            WritePersistentProperties(modelClass);
            WriteCalculatedProperties(modelClass);
            WritePersistentNavigationProperties(modelClass);
            WriteCalculatedNavigationProperties(modelClass);

            Output("}");

            EndNamespace(modelClass.Namespace);
            NL();
         }

         // Enums

         foreach (ModelEnum modelEnum in modelRoot.Enums)
         {
            manager.StartNewFile(Path.Combine(modelRoot.EnumOutputDirectory, $"{modelEnum.Name}.{modelRoot.FileNameMarker}.cs"));

            Output("using System;");
            NL();

            BeginNamespace(modelEnum.Namespace);

            Output($"public enum {modelEnum.Name} : {modelEnum.ValueType}");
            Output("{");

            ModelEnumValue[] values = modelEnum.Values.ToArray();
            for (int index = 0; index < values.Length; ++index)
            {
               if (string.IsNullOrEmpty(values[index].Value))
                  Output($"{values[index].Name}{(index < values.Length - 1 ? "," : "")}");
               else
                  Output($"{values[index].Name} = {values[index].Value}{(index < values.Length - 1 ? "," : "")}");
            }
            Output("}");

            EndNamespace(modelEnum.Namespace);
         }

         manager.StartNewFile(Path.Combine(modelRoot.ContextOutputDirectory, $"{modelRoot.EntityContainerName}DatabaseInitializer.{modelRoot.FileNameMarker}.cs"));
         WriteDatabaseInitializer(modelRoot);

         manager.StartNewFile(Path.Combine(modelRoot.ContextOutputDirectory, $"{modelRoot.EntityContainerName}DbMigrationConfiguration.{modelRoot.FileNameMarker}.cs"));
         WriteMigrationConfiguration(modelRoot);

         manager.StartNewFile(Path.Combine(modelRoot.ContextOutputDirectory, $"{modelRoot.EntityContainerName}.{modelRoot.FileNameMarker}.cs"));
         WriteDbContext(modelRoot);
      }

      List<string> GetAdditionalUsingStatements(ModelRoot modelRoot)
      {
         List<string> result = new List<string>();
         List<string> attributeTypes = modelRoot.Types.OfType<ModelClass>().SelectMany(c => c.Attributes).Select(a => a.Type).Distinct().ToList();

         if (attributeTypes.Any(t => t.IndexOf("Geometry", StringComparison.Ordinal) > -1 || t.IndexOf("Geography", StringComparison.Ordinal) > -1))
         {
            result.Add("using System.Data.Entity.Spatial;");
         }

         return result;
      }

      void NL()
      {
         WriteLine("");
      }

      static string[] NonNullableTypes = {
   "Binary",
   "Geography",
   "GeographyCollection",
   "GeographyLineString",
   "GeographyMultiLineString",
   "GeographyMultiPoint",
   "GeographyMultiPolygon",
   "GeographyPoint",
   "GeographyPolygon",
   "Geometry",
   "GeometryCollection",
   "GeometryLineString",
   "GeometryMultiLineString",
   "GeometryMultiPoint",
   "GeometryMultiPolygon",
   "GeometryPoint",
   "GeometryPolygon",
   "String"
};

      bool IsNullable(ModelAttribute modelAttribute)
      {
         return !modelAttribute.Required &&
                !modelAttribute.IsIdentity &&
                !modelAttribute.IsConcurrencyToken &&
                !NonNullableTypes.Contains(modelAttribute.Type);
      }

      void Output(string text)
      {
         if (text.StartsWith("}"))
            PopIndent();
         WriteLine(text);
         if (text.EndsWith("{"))
            PushIndent("   ");
      }

      void Output(string template, params object[] items)
      {
         string text = string.Format(template, items);
         Output(text);
      }

      void OutputChopped(IEnumerable<string> segments)
      {
         if (!segments.Any())
            return;

         string[] segmentArray = segments.ToArray();
         int indent = segmentArray[0].IndexOf('.');

         if (indent == -1)
         {
            if (segmentArray.Length > 1)
            {
               segmentArray[0] = $"{segmentArray[0]}.{segmentArray[1]}";
               indent = segmentArray[0].IndexOf('.');
               segmentArray = segmentArray.Where((source, index) => index != 1).ToArray();
            }
         }

         for (int index = 1; index < segmentArray.Length; ++index)
            segmentArray[index] = $"{new string(' ', indent)}.{segmentArray[index]}";

         if (!segmentArray[segmentArray.Length - 1].Trim().EndsWith(";"))
            segmentArray[segmentArray.Length - 1] = segmentArray[segmentArray.Length - 1] + ";";

         foreach (string segment in segmentArray)
            Output(segment);
      }

      void BeginNamespace(string ns)
      {
         if (!string.IsNullOrEmpty(ns))
         {
            Output($"namespace {ns}");
            Output("{");
         }
      }

      void EndNamespace(string ns)
      {
         if (!string.IsNullOrEmpty(ns))
            Output("}");
      }

      List<string> GetRequiredParameters(ModelClass modelClass, bool? haveDefaults = null)
      {
         List<string> requiredParameters = new List<string>();

         if (haveDefaults != true)
         {
            requiredParameters.AddRange(modelClass.AllRequiredAttributes
               .Where(x => !x.IsIdentity && x.SetterVisibility == SetterAccessModifier.Public && string.IsNullOrEmpty(x.InitialValue))
               .Select(x => $"{x.CLRType} _{x.Name.ToLower()}"));

            requiredParameters.AddRange(modelClass.AllRequiredNavigationProperties()
               .Select(x => $"{x.ClassType.Name} _{x.PropertyName.ToLower().Trim('_')}"));
         }

         if (haveDefaults != false)
         {
            requiredParameters.AddRange(modelClass.AllRequiredAttributes
               .Where(x => !x.IsIdentity && x.SetterVisibility == SetterAccessModifier.Public &&
                           !string.IsNullOrEmpty(x.InitialValue))
               .Select(x =>
               {
                  string quote = x.CLRType == "string" ? "\"" : x.CLRType == "char" ? "'" : "";
                  string value = x.InitialValue.Trim('"', '\'');
                  return $"{x.CLRType} _{x.Name.ToLower()} = {quote}{value}{quote}";
               }));
         }

         return requiredParameters;
      }

      List<string> GetRequiredParameterNames(ModelClass modelClass)
      {
         List<string> requiredParameterNames = modelClass.AllRequiredAttributes
            .Where(x => !x.IsIdentity && x.SetterVisibility == SetterAccessModifier.Public &&
                        string.IsNullOrEmpty(x.InitialValue))
            .Select(x => $"_{x.Name.ToLower().Trim('_')}")
            .ToList();

         requiredParameterNames.AddRange(modelClass.AllRequiredNavigationProperties()
            .Select(x => $"_{x.PropertyName.ToLower().Trim('_')}"));

         requiredParameterNames.AddRange(modelClass.AllRequiredAttributes
            .Where(x => !x.IsIdentity && x.SetterVisibility == SetterAccessModifier.Public &&
                        !string.IsNullOrEmpty(x.InitialValue))
            .Select(x => $"_{x.Name.ToLower().Trim('_')}"));

         return requiredParameterNames;
      }

      void WriteDefaultConstructorBody(ModelClass modelClass)
      {
         foreach (ModelAttribute modelAttribute in modelClass.Attributes.Where(x => x.SetterVisibility == SetterAccessModifier.Public &&
                                                                                    !string.IsNullOrEmpty(x.InitialValue) &&
                                                                                    x.InitialValue != "null"))
         {
            string quote = modelAttribute.Type == "String" ? "\"" : modelAttribute.Type == "Char" ? "'" : "";
            Output($"{modelAttribute.Name} = {quote}{modelAttribute.InitialValue}{quote};");
         }

         foreach (NavigationProperty navigationProperty in modelClass.LocalNavigationProperties().Where(x => x.AssociationObject.Persistent && x.IsCollection && !x.ConstructorParameterOnly))
            Output($"{navigationProperty.PropertyName} = new {navigationProperty.AssociationObject.CollectionClass}<{navigationProperty.ClassType.Name}>();");

         NL();
         Output("Init();");
      }

      void WriteConstructor(ModelClass modelClass)
      {
         Output("partial void Init();");
         NL();

         /***********************************************************************/
         // Default constructor
         /***********************************************************************/

         string visibility = GetRequiredParameters(modelClass, false).Any() ? "protected" : "public";

         if (visibility == "public")
         {
            Output("/// <summary>");
            Output("/// Default constructor");
            Output("/// </summary>");
         }
         else
         {
            Output("/// <summary>");
            Output("/// Default constructor. Protected due to required properties, but present because EF needs it.");
            Output("/// </summary>");
         }

         if (modelClass.Superclass != null)
            Output($"{visibility} {modelClass.Name}(): base()");
         else
            Output($"{visibility} {modelClass.Name}()");
         Output("{");

         WriteDefaultConstructorBody(modelClass);

         Output("}");
         NL();

         /***********************************************************************/
         // Constructor with required parameters (if necessary)
         /***********************************************************************/

         if (visibility == "protected")
         {
            Output("/// <summary>");
            Output("/// Public constructor with required data");
            Output("/// </summary>");
            WriteConstructorComments(modelClass);
            Output($"public {modelClass.Name}({string.Join(", ", GetRequiredParameters(modelClass))})");
            Output("{");

            foreach (ModelAttribute requiredAttribute in modelClass.AllRequiredAttributes.Where(x => !x.IsIdentity && x.SetterVisibility == SetterAccessModifier.Public))
            {
               if (requiredAttribute.Type == "String")
                  Output($"if (string.IsNullOrEmpty(_{requiredAttribute.Name.ToLower().Trim('_')})) throw new ArgumentNullException(nameof(_{requiredAttribute.Name.ToLower().Trim('_')}));");
               else if (requiredAttribute.Type.StartsWith("Geo"))
                  Output($"if (_{requiredAttribute.Name.ToLower().Trim('_')} == null) throw new ArgumentNullException(nameof(_{requiredAttribute.Name.ToLower().Trim('_')}));");
               Output($"{requiredAttribute.Name} = _{requiredAttribute.Name.ToLower().Trim('_')};");
            }

            foreach (NavigationProperty requiredNavigationProperty in modelClass.AllRequiredNavigationProperties())
            {
               string parameterName = requiredNavigationProperty.PropertyName.ToLower().Trim('_');
               Output($"if (_{parameterName} == null) throw new ArgumentNullException(nameof(_{parameterName}));");

               if (requiredNavigationProperty.IsCollection)
                  Output($"{requiredNavigationProperty.PropertyName}.Add(_{parameterName});");
               else if (requiredNavigationProperty.ConstructorParameterOnly)
               {
                  UnidirectionalAssociation association = requiredNavigationProperty.AssociationObject as UnidirectionalAssociation;
                  if (association.TargetMultiplicity == Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroMany)
                     Output($"{requiredNavigationProperty.PropertyName}.{association.TargetPropertyName}.Add(this);");
                  else
                     Output($"{requiredNavigationProperty.PropertyName}.{association.TargetPropertyName} = this;");
               }
               else
                  Output($"{requiredNavigationProperty.PropertyName} = _{parameterName};");

               NL();
            }

            foreach (NavigationProperty navigationProperty in modelClass.LocalNavigationProperties().Where(x => x.AssociationObject.Persistent && x.IsCollection && !x.ConstructorParameterOnly))
               Output($"{navigationProperty.PropertyName} = new {navigationProperty.AssociationObject.CollectionClass}<{navigationProperty.ClassType.Name}>();");

            Output("}");
            NL();


            Output("/// <summary>");
            Output("/// Static create function (for use in LINQ queries, etc.)");
            Output("/// </summary>");
            WriteConstructorComments(modelClass);
            Output($"public static {modelClass.Name} Create({string.Join(", ", GetRequiredParameters(modelClass))})");
            Output("{");
            Output($"return new {modelClass.Name}({string.Join(", ", GetRequiredParameterNames(modelClass))});");
            Output("}");
            NL();


         }
      }

      void WriteConstructorComments(ModelClass modelClass)
      {
         foreach (ModelAttribute requiredAttribute in modelClass.AllRequiredAttributes.Where(x => !x.IsIdentity && x.SetterVisibility == SetterAccessModifier.Public))
            Output($@"/// <param name=""_{requiredAttribute.Name.ToLower().Trim('_')}"">{requiredAttribute.Summary}</param>");
         // TODO: Add comment if available
         foreach (NavigationProperty requiredNavigationProperty in modelClass.AllRequiredNavigationProperties())
            Output($@"/// <param name=""_{requiredNavigationProperty.PropertyName.ToLower().Trim('_')}""></param>");
      }

      void WritePersistentProperties(ModelClass modelClass)
      {
         if (!modelClass.Attributes.Any(x => x.Persistent))
            return;

         Output("// Persistent properties");
         List<string> segments = new List<string>();
         NL();

         foreach (ModelAttribute modelAttribute in modelClass.Attributes.Where(x => x.Persistent))
         {
            segments.Clear();

            if (modelAttribute.IsIdentity)
               segments.Add("Identity");
            if (modelAttribute.Required || modelAttribute.IsIdentity)
               segments.Add("Required");
            if (modelAttribute.Indexed)
               segments.Add("Indexed");
            if (modelAttribute.MaxLength > 0)
               segments.Add($"Max length = {modelAttribute.MaxLength}");
            if (!string.IsNullOrEmpty(modelAttribute.InitialValue))
            {
               string quote = modelAttribute.CLRType == "string" ? "\"" : modelAttribute.CLRType == "char" ? "'" : "";
               segments.Add($"Default value = {quote}{modelAttribute.InitialValue}{quote}");
            }

            string nullable = IsNullable(modelAttribute) ? "?" : "";

            if (!modelAttribute.AutoProperty)
            {
               Output($"private {modelAttribute.CLRType}{nullable} _{modelAttribute.Name};");
               Output($"partial void Set{modelAttribute.Name}({modelAttribute.CLRType}{nullable} oldValue, ref {modelAttribute.CLRType}{nullable} newValue);");
               Output($"partial void Get{modelAttribute.Name}(ref {modelAttribute.CLRType}{nullable} result);");
               NL();
            }

            if (!string.IsNullOrEmpty(modelAttribute.Summary) || segments.Any())
            {
               Output("/// <summary>");
               if (segments.Any())
                  Output($"/// {string.Join(", ", segments)}");
               if (!string.IsNullOrEmpty(modelAttribute.Summary))
                  Output("/// {0}", modelAttribute.Summary);
               Output("/// </summary>");
            }

            string setterVisibility = modelAttribute.SetterVisibility == SetterAccessModifier.Protected ? "protected " : modelAttribute.SetterVisibility == SetterAccessModifier.Internal ? "internal " : "";

            if (modelAttribute.AutoProperty)
               Output($"public {modelAttribute.CLRType}{nullable} {modelAttribute.Name} {{ get; {setterVisibility}set; }}");
            else
            {
               Output($"public {modelAttribute.CLRType}{nullable} {modelAttribute.Name}");
               Output("{");
               Output($"get {{ {modelAttribute.CLRType}{nullable} value = _{modelAttribute.Name}; Get{modelAttribute.Name}(ref value); return (_{modelAttribute.Name} = value); }}");
               Output($"{setterVisibility}set {{ {modelAttribute.CLRType}{nullable} oldValue = _{modelAttribute.Name}; Set{modelAttribute.Name}(oldValue, ref value); _{modelAttribute.Name} = value; }}");
               Output("}");
            }

            NL();
         }

         if (!modelClass.AllAttributes.Any(x => x.IsConcurrencyToken) &&
             (modelClass.Concurrency == ConcurrencyOverride.Optimistic || modelClass.ModelRoot.ConcurrencyDefault == Concurrency.Optimistic))
         {
            Output("/// <summary>");
            Output("/// Concurrency token");
            Output("/// </summary>");
            Output("public DateTime Timestamp { get; set; }");
            NL();
         }
      }

      void WriteCalculatedProperties(ModelClass modelClass)
      {
         if (modelClass.Attributes.All(x => x.Persistent))
            return;

         Output("// Calculated properties");
         NL();

         foreach (ModelAttribute calculatedAttribute in modelClass.Attributes.Where(x => !x.Persistent))
         {
            string nullable = IsNullable(calculatedAttribute) ? "?" : "";

            Output("partial void Get{0}(ref {1}{2} value);", calculatedAttribute.Name, calculatedAttribute.CLRType, nullable);
            Output("partial void Set{0}({1}{2} value);", calculatedAttribute.Name, calculatedAttribute.CLRType, nullable);

            Output("/// <summary>");
            Output("/// Calculated property");
            if (!string.IsNullOrEmpty(calculatedAttribute.Summary))
               Output("/// {0}", calculatedAttribute.Summary);
            Output("/// </summary>");

            if (!string.IsNullOrEmpty(calculatedAttribute.Description))
            {
               Output("/// <remarks>");
               Output("/// {0}", calculatedAttribute.Description);
               Output("/// </remarks>");
            }

            string setterVisibility = calculatedAttribute.SetterVisibility == SetterAccessModifier.Protected ? "protected " : calculatedAttribute.SetterVisibility == SetterAccessModifier.Internal ? "internal " : "";
            string isVirtual = calculatedAttribute.Virtual ? "virtual " : "";

            Output($"public {isVirtual}{calculatedAttribute.CLRType}{nullable} {calculatedAttribute.Name}");
            Output("{");
            Output($"get {{ {calculatedAttribute.CLRType}{nullable} value = default({calculatedAttribute.CLRType}{nullable}); Get{calculatedAttribute.Name}(ref value); return value; }}");
            Output($"{setterVisibility}set {{ Set{calculatedAttribute.Name}(value); }}");
            Output("}");
            NL();
         }
      }

      void WritePersistentNavigationProperties(ModelClass modelClass)
      {
         if (!modelClass.LocalNavigationProperties().Any(x => x.AssociationObject.Persistent))
            return;

         Output("// Persistent navigation properties");
         NL();

         foreach (NavigationProperty navigationProperty in modelClass.LocalNavigationProperties().Where(x => x.AssociationObject.Persistent && !x.ConstructorParameterOnly))
         {
            string type = navigationProperty.IsCollection
                              ? $"ICollection<{navigationProperty.ClassType.Name}>"
                              : navigationProperty.ClassType.Name;

            List<string> comments = new List<string>();
            if (navigationProperty.Required)
               comments.Add("Required");
            string comment = comments.Count > 0 ? $" // {string.Join(", ", comments)}" : "";

            Output($"public virtual {type} {navigationProperty.PropertyName} {{ get; set; }} {comment}");
         }
      }

      void WriteCalculatedNavigationProperties(ModelClass modelClass)
      {
         if (modelClass.LocalNavigationProperties().All(x => x.AssociationObject.Persistent))
            return;

         Output("// Calculated navigation properties");
         NL();

         foreach (NavigationProperty navigationProperty in modelClass.LocalNavigationProperties().Where(x => !x.AssociationObject.Persistent && !x.ConstructorParameterOnly))
         {
            string type = navigationProperty.IsCollection
                              ? $"ICollection<{navigationProperty.ClassType.Name}>"
                              : navigationProperty.ClassType.Name;

            Output($"partial void Get{navigationProperty.PropertyName}(ref {type} value);");
            Output($"partial void Set{navigationProperty.PropertyName}({type} value);");

            Output($"public {type} {navigationProperty.PropertyName}");
            Output("{");
            Output($"get {{ {type} value = null; Get{navigationProperty.PropertyName}(ref value); return value; }}");
            Output($"set {{ Set{navigationProperty.PropertyName}(value); }}");
            Output("}");
            NL();
         }
      }

      void WriteDatabaseInitializer(ModelRoot modelRoot)
      {
         Output("using System.Data.Entity;");
         NL();

         BeginNamespace(modelRoot.Namespace);

         if (modelRoot.DatabaseInitializerType == DatabaseInitializerKind.MigrateDatabaseToLatestVersion)
            Output($"public partial class {modelRoot.EntityContainerName}DatabaseInitializer : MigrateDatabaseToLatestVersion<{modelRoot.EntityContainerName}, {modelRoot.EntityContainerName}DbMigrationConfiguration>");
         else
            Output($"public partial class {modelRoot.EntityContainerName}DatabaseInitializer : {modelRoot.DatabaseInitializerType}<{modelRoot.EntityContainerName}>");

         Output("{");
         Output("}");
         EndNamespace(modelRoot.Namespace);
      }

      void WriteMigrationConfiguration(ModelRoot modelRoot)
      {
         //if (modelRoot.DatabaseInitializerType != DatabaseInitializerKind.MigrateDatabaseToLatestVersion)
         //   return;

         Output("using System.Data.Entity.Migrations;");
         NL();

         BeginNamespace(modelRoot.Namespace);
         Output("public sealed partial class {0}DbMigrationConfiguration : DbMigrationsConfiguration<{0}>", modelRoot.EntityContainerName);

         Output("{");
         Output("partial void Init();");
         NL();

         Output("public {0}DbMigrationConfiguration()", modelRoot.EntityContainerName);
         Output("{");
         Output("AutomaticMigrationsEnabled = {0};", modelRoot.AutomaticMigrationsEnabled.ToString().ToLower());
         Output("AutomaticMigrationDataLossAllowed = false;");
         Output("Init();");
         Output("}");

         Output("}");
         EndNamespace(modelRoot.Namespace);
      }

      private readonly string[] SpatialTypes =
      {
      "Geography",
      "GeographyCollection",
      "GeographyLineString",
      "GeographyMultiLineString",
      "GeographyMultiPoint",
      "GeographyMultiPolygon",
      "GeographyPoint",
      "GeographyPolygon",
      "Geometry",
      "GeometryCollection",
      "GeometryLineString",
      "GeometryMultiLineString",
      "GeometryMultiPoint",
      "GeometryMultiPolygon",
      "GeometryPoint",
      "GeometryPolygon"
   };

      void WriteDbContext(ModelRoot modelRoot)
      {
         Output("using System;");
         Output("using System.Collections.Generic;");
         Output("using System.Linq;");
         Output("using System.ComponentModel.DataAnnotations.Schema;");
         Output("using Microsoft.EntityFrameworkCore;");
         NL();

         BeginNamespace(modelRoot.Namespace);

         Output($"{modelRoot.EntityContainerAccess.ToString().ToLower()} partial class {modelRoot.EntityContainerName} : Microsoft.EntityFrameworkCore.DbContext");
         Output("{");

         PluralizationService pluralizationService = PluralizationService.CreateService(CultureInfo.CurrentCulture);

         /***********************************************************************/
         // generate DBSets
         /***********************************************************************/

         IEnumerable<ModelClass> classesWithTables = null;

         switch (modelRoot.InheritanceStrategy)
         {
            case CodeStrategy.TablePerType:
               classesWithTables = modelRoot.Types.OfType<ModelClass>().OrderBy(x => x.Name);
               break;
            case CodeStrategy.TablePerConcreteType:
               classesWithTables = modelRoot.Types.OfType<ModelClass>().Where(mc => !mc.IsAbstract).OrderBy(x => x.Name);
               break;
            case CodeStrategy.TablePerHierarchy:
               classesWithTables = modelRoot.Types.OfType<ModelClass>().Where(x => x.Superclass == null).OrderBy(x => x.Name);
               break;
         }

         if (classesWithTables != null)
         {
            foreach (ModelClass modelClass in classesWithTables)
            {
               string dbSetName;

               if (!string.IsNullOrEmpty(modelClass.DbSetName))
                  dbSetName = modelClass.DbSetName;
               else
                  dbSetName = pluralizationService.IsSingular(modelClass.Name)
                     ? pluralizationService.Pluralize(modelClass.Name)
                     : modelClass.Name;

               Output($"public Microsoft.EntityFrameworkCore.DbSet<{modelClass.Name}> {dbSetName} {{ get; set; }}");
            }

            NL();
         }

         /***********************************************************************/
         // construction
         /***********************************************************************/

         Output("partial void CustomInit(ref DbContextOptionsBuilder optionsBuilder);");
         NL();

         Output($"protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)");
         Output($"{");
         if (!string.IsNullOrEmpty(modelRoot.ConnectionString) || !string.IsNullOrEmpty(modelRoot.ConnectionStringName))
         {
            string connectionString = string.IsNullOrEmpty(modelRoot.ConnectionString)
                                         ? $@"System.Configuration.ConfigurationManager.ConnectionStrings[""{modelRoot.ConnectionStringName}""].ConnectionString"
                                         : $@"""{modelRoot.ConnectionString}""";
            Output($"optionsBuilder.UseSqlServer(connectionString);");
         }
         else
         {
            Output($"#warning Database option not generated for {modelRoot.EntityContainerName} since no default connection string was specified in the model");
         }
         Output("CustomInit(ref optionsBuilder);");
         Output($"}");
         NL();

         Output("partial void OnModelCreatingImpl(System.Data.Entity.DbModelBuilder modelBuilder);");
         Output("partial void OnModelCreatedImpl(System.Data.Entity.DbModelBuilder modelBuilder);");
         NL();

         /***********************************************************************/
         // OnModelCreating 
         /***********************************************************************/
         Output("protected override void OnModelCreating(System.Data.Entity.DbModelBuilder modelBuilder)");
         Output("{");
         Output("base.OnModelCreating(modelBuilder);");
         Output("OnModelCreatingImpl(modelBuilder);");
         NL();

         Output($"modelBuilder.HasDefaultSchema(\"{modelRoot.DatabaseSchema}\");");

         List<string> segments = new List<string>();

         Sawczyn.EFDesigner.EFModel.Multiplicity[] singles = { Sawczyn.EFDesigner.EFModel.Multiplicity.One, Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroOne };
         Sawczyn.EFDesigner.EFModel.Multiplicity[] multiples = { Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroMany };
         List<Association> visited = new List<Association>();
         List<string> foreignKeyColumns = new List<string>();

         foreach (ModelClass modelClass in modelRoot.Types.OfType<ModelClass>().OrderBy(x => x.Name))
         {
            segments.Clear();
            foreignKeyColumns.Clear();
            NL();

            // class level
            segments.Add($"modelBuilder.Entity<{modelClass.Name}>()");

            // note: this must come before the 'ToTable' call or there's a runtime error
            if (modelRoot.InheritanceStrategy == CodeStrategy.TablePerConcreteType && modelClass.Superclass != null)
               segments.Add("Map(x => x.MapInheritedProperties())");

            if (classesWithTables.Contains(modelClass))
            {
               if (modelClass.DatabaseSchema == modelClass.ModelRoot.DatabaseSchema)
                  segments.Add($"ToTable(\"{modelClass.TableName}\")");
               else
                  segments.Add($"ToTable(\"{modelClass.TableName}\", \"{modelClass.DatabaseSchema}\")");
            }

            List<string> identityProperties = modelClass.IdentityPropertyNames.ToList();
            if (identityProperties.Count == 1)
               segments.Add($"HasKey(t => t.{identityProperties[0]})");
            else
               segments.Add($"HasKey(t => new {{ t.{string.Join(", t.", identityProperties)} }})");

            foreach (ModelAttribute indexed in modelClass.Attributes.Where(x => x.Indexed))
               segments.Add($"HasIndex(t => t.{indexed.Name})");

            foreach (ModelAttribute transient in modelClass.Attributes.Where(x => !x.Persistent))
               segments.Add($"Ignore(t => t.{transient.Name})");

            if (modelRoot.ChopMethodChains)
               OutputChopped(segments);
            else
               Output(string.Join(".", segments) + ";");

            // attribute level
            foreach (ModelAttribute modelAttribute in modelClass.Attributes.Where(x => x.Persistent && !SpatialTypes.Contains(x.Type)))
            {
               segments.Clear();

               if (modelAttribute.MaxLength > 0)
                  segments.Add($"HasMaxLength({modelAttribute.MaxLength})");
               if (modelAttribute.Required)
                  segments.Add("IsRequired()");
               if (modelAttribute.IsConcurrencyToken)
                  segments.Add("IsRowVersion()");
               if (modelAttribute.IsIdentity)
                  segments.Add("HasDatabaseGeneratedOption(DatabaseGeneratedOption.Identity)");

               if (segments.Any())
               {
                  segments.Insert(0, $"modelBuilder.Entity<{modelClass.Name}>()");
                  segments.Insert(1, $"Property(t => t.{modelAttribute.Name})");

                  if (modelRoot.ChopMethodChains)
                     OutputChopped(segments);
                  else
                     Output(string.Join(".", segments) + ";");
               }
            }

            // Navigation endpoints are distingished as Source and Target. They are also distinguished as Principal
            // and Dependent. How do these map?
            // In the case of one-to-one or zero-to-one-to-zero-to-one, it's model dependent and the user has to tell us
            // In all other cases, we can tell by the cardinalities of the associations
            // What matters is the Principal and Dependent classifications, so we look at those. 
            // Source and Target are accidents of where the user started drawing the association.

            // navigation properties
            foreach (UnidirectionalAssociation association in Association.GetLinksToTargets(modelClass).OfType<UnidirectionalAssociation>())
            {
               if (visited.Contains(association)) continue;
               visited.Add(association);

               // Certain associations cascade delete automatically. Also, the user may ask for it.
               // We only generate a cascade delete call if the user asks for it. EF will handle the rest automatically, and it can
               // cause issues if we make the call when it's not needed.
               bool cascadeDelete = association.TargetDeleteAction != DeleteAction.None;

               segments.Clear();
               segments.Add($"modelBuilder.Entity<{modelClass.Name}>()");

               switch (association.TargetMultiplicity) // realized by property on source
               {
                  case Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroMany:
                     segments.Add($"HasMany(x => x.{association.TargetPropertyName})");
                     break;
                  case Sawczyn.EFDesigner.EFModel.Multiplicity.One:
                     segments.Add($"HasRequired(x => x.{association.TargetPropertyName})");
                     cascadeDelete = true;
                     break;
                  case Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroOne:
                     segments.Add($"HasOptional(x => x.{association.TargetPropertyName})");
                     break;
                     //case Sawczyn.EFDesigner.EFModel.Multiplicity.OneMany:
                     //   segments.Add($"HasMany(x => x.{association.TargetPropertyName})");
                     //   break;
               }

               switch (association.SourceMultiplicity) // realized by property on target, but no property on target
               {
                  case Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroMany:
                     segments.Add("WithMany()");
                     if (association.TargetMultiplicity == Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroMany)
                     {
                        segments.Add("Map(x => { " +
                           $@"x.ToTable(""{association.Source.Name}_x_{association.TargetPropertyName}""); " +
                           $@"x.MapLeftKey(""{association.Source.Name}_{association.Source.AllAttributes.FirstOrDefault(a => a.IsIdentity)?.Name}""); " +
                           $@"x.MapRightKey(""{association.Target.Name}_{association.Target.AllAttributes.FirstOrDefault(a => a.IsIdentity)?.Name}""); " +
                           "})");
                     }
                     break;
                  case Sawczyn.EFDesigner.EFModel.Multiplicity.One:
                     if (association.TargetMultiplicity == Sawczyn.EFDesigner.EFModel.Multiplicity.One)
                     {
                        if (association.TargetRole == EndpointRole.Dependent)
                           segments.Add("WithRequiredDependent()");
                        else
                           segments.Add("WithRequiredPrincipal()");
                     }
                     else
                     {
                        segments.Add("WithRequired()");
                     }

                     cascadeDelete = true;
                     break;
                  case Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroOne:
                     if (association.TargetMultiplicity == Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroOne)
                     {
                        if (association.TargetRole == EndpointRole.Dependent)
                           segments.Add("WithOptionalDependent()");
                        else
                           segments.Add("WithOptionalPrincipal()");
                     }
                     else
                     {
                        segments.Add("WithOptional()");
                     }

                     break;
                     //case Sawczyn.EFDesigner.EFModel.Multiplicity.OneMany:
                     //   segments.Add("HasMany()");
                     //   break;
               }

               string foreignKeySegment = CreateForeignKeyColumnSegment(association, foreignKeyColumns);
               if (foreignKeySegment != null) segments.Add(foreignKeySegment);

               if (cascadeDelete)
                  segments.Add("WillCascadeOnDelete()");

               if (modelRoot.ChopMethodChains)
                  OutputChopped(segments);
               else
                  Output(string.Join(".", segments) + ";");
            }

            foreach (BidirectionalAssociation association in Association.GetLinksToSources(modelClass).OfType<BidirectionalAssociation>())
            {
               if (visited.Contains(association)) continue;
               visited.Add(association);

               // TODO: fix cascade delete
               bool cascadeDelete = association.SourceDeleteAction != DeleteAction.None;

               segments.Clear();
               segments.Add($"modelBuilder.Entity<{modelClass.Name}>()");

               switch (association.SourceMultiplicity) // realized by property on target
               {
                  case Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroMany:
                     segments.Add($"HasMany(x => x.{association.SourcePropertyName})");
                     break;
                  case Sawczyn.EFDesigner.EFModel.Multiplicity.One:
                     segments.Add($"HasRequired(x => x.{association.SourcePropertyName})");
                     cascadeDelete = true;
                     break;
                  case Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroOne:
                     segments.Add($"HasOptional(x => x.{association.SourcePropertyName})");
                     break;
                     //one or more constraint not supported in EF6. TODO: make this possible ... later
                     //case Sawczyn.EFDesigner.EFModel.Multiplicity.OneMany:
                     //   segments.Add($"HasMany(x => x.{association.SourcePropertyName})");
                     //   break;
               }

               switch (association.TargetMultiplicity) // realized by property on source
               {
                  case Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroMany:
                     segments.Add($"WithMany(x => x.{association.TargetPropertyName})");
                     if (association.SourceMultiplicity == Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroMany)
                     {
                        segments.Add("Map(x => { " +
                           $@"x.ToTable(""{association.SourcePropertyName}_x_{association.TargetPropertyName}""); " +
                           $@"x.MapLeftKey(""{association.Source.Name}_{association.Source.AllAttributes.FirstOrDefault(a => a.IsIdentity)?.Name}""); " +
                           $@"x.MapRightKey(""{association.Target.Name}_{association.Target.AllAttributes.FirstOrDefault(a => a.IsIdentity)?.Name}""); " +
                           "})");
                     }
                     break;
                  case Sawczyn.EFDesigner.EFModel.Multiplicity.One:
                     if (association.SourceMultiplicity == Sawczyn.EFDesigner.EFModel.Multiplicity.One)
                     {
                        if (association.SourceRole == EndpointRole.Dependent)
                           segments.Add($"WithRequiredDependent(x => x.{association.TargetPropertyName})");
                        else
                           segments.Add($"WithRequiredPrincipal(x => x.{association.TargetPropertyName})");
                     }
                     else
                     {
                        segments.Add($"WithRequired(x => x.{association.TargetPropertyName})");
                     }

                     cascadeDelete = true;
                     break;
                  case Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroOne:
                     if (association.SourceMultiplicity == Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroOne)
                     {
                        if (association.SourceRole == EndpointRole.Dependent)
                           segments.Add($"WithOptionalDependent(x => x.{association.TargetPropertyName})");
                        else
                           segments.Add($"WithOptionalPrincipal(x => x.{association.TargetPropertyName})");
                     }
                     else
                     {
                        segments.Add($"WithOptional(x => x.{association.TargetPropertyName})");
                     }

                     break;
                     //one or more constraint not supported in EF6. TODO: make this possible ... later
                     //case Sawczyn.EFDesigner.EFModel.Multiplicity.OneMany:
                     //   segments.Add($"HasMany(x => x.{association.TargetPropertyName})");
                     //   break;
               }

               string foreignKeySegment = CreateForeignKeyColumnSegment(association, foreignKeyColumns);
               if (foreignKeySegment != null) segments.Add(foreignKeySegment);

               if (cascadeDelete)
                  segments.Add("WillCascadeOnDelete()");

               if (modelRoot.ChopMethodChains)
                  OutputChopped(segments);
               else
                  Output(string.Join(".", segments) + ";");
            }
         }

         NL();

         Output("OnModelCreatedImpl(modelBuilder);");
         Output("}");

         Output("}");

         EndNamespace(modelRoot.Namespace);
      }

      string CreateForeignKeyColumnSegment(Association association, List<string> foreignKeyColumns)
      {
         // foreign key definitions always go in the table representing the Dependent end of the association
         // if there is no dependent end (i.e., many-to-many), there are no foreign keys
         string nameBase = string.Empty;
         if (association.SourceRole == EndpointRole.Dependent)
            nameBase = association.TargetPropertyName;
         else if (association.TargetRole == EndpointRole.Dependent)
            nameBase = (association as BidirectionalAssociation)?.SourcePropertyName ?? association.Source.Name;
         else
            return null;

         string columnName = $"{nameBase}_Id";
         if (foreignKeyColumns.Contains(columnName))
         {
            int index = 0;
            do
            {
               columnName = $"{nameBase}{++index}_Id";
            } while (foreignKeyColumns.Contains(columnName));
         }
         foreignKeyColumns.Add(columnName);
         return $@"Map(x => x.MapKey(""{columnName}""))";
      }

      class Manager
      {
         private class Block
         {
            public string Name;
            public int Start, Length;
            public bool IncludeInDefault;
         }

         private Block currentBlock;
         private readonly List<Block> files = new List<Block>();
         private readonly Block footer = new Block();
         private readonly Block header = new Block();
         private readonly ITextTemplatingEngineHost host;
         private readonly StringBuilder template;
         protected readonly List<string> generatedFileNames = new List<string>();

         public static Manager Create(ITextTemplatingEngineHost host, StringBuilder template)
         {
            return (host is IServiceProvider) ? new VSManager(host, template) : new Manager(host, template);
         }

         public string FileNameMarker { get; set; }

         public void StartNewFile(string name)
         {
            if (name == null)
               throw new ArgumentNullException("name");
            CurrentBlock = new Block { Name = name };
         }

         public void StartFooter(bool includeInDefault = true)
         {
            CurrentBlock = footer;
            footer.IncludeInDefault = includeInDefault;
         }

         public void StartHeader(bool includeInDefault = true)
         {
            CurrentBlock = header;
            header.IncludeInDefault = includeInDefault;
         }

         public void EndBlock()
         {
            if (CurrentBlock == null)
               return;
            CurrentBlock.Length = template.Length - CurrentBlock.Start;
            if (CurrentBlock != header && CurrentBlock != footer)
               files.Add(CurrentBlock);
            currentBlock = null;
         }

         public virtual void Process(bool split)
         {
            if (split)
            {
               EndBlock();
               string headerText = template.ToString(header.Start, header.Length);
               string footerText = template.ToString(footer.Start, footer.Length);
               string outputPath = Path.GetDirectoryName(host.TemplateFile);
               files.Reverse();
               if (!footer.IncludeInDefault)
                  template.Remove(footer.Start, footer.Length);

               foreach (Block block in files)
               {
                  string fileName = Path.Combine(outputPath, block.Name);
                  string directoryPrefix = block.Name.IndexOf('\\') > -1 ? block.Name.Substring(0, block.Name.LastIndexOf('\\')) : ".";
                  string content = headerText + template.ToString(block.Start, block.Length) + footerText;
                  generatedFileNames.Add(fileName);
                  CreateFile(fileName, content);
                  template.Remove(block.Start, block.Length);
               }

               if (!header.IncludeInDefault)
                  template.Remove(header.Start, header.Length);
            }
         }

         protected virtual void CreateFile(string fileName, string content)
         {
            if (IsFileContentDifferent(fileName, content))
               File.WriteAllText(fileName, content);
         }

         public virtual string GetCustomToolNamespace(string fileName)
         {
            return null;
         }

         public virtual string DefaultProjectNamespace
         {
            get { return null; }
         }

         protected bool IsFileContentDifferent(string fileName, string newContent)
         {
            return !(File.Exists(fileName) && File.ReadAllText(fileName) == newContent);
         }

         private Manager(ITextTemplatingEngineHost host, StringBuilder template)
         {
            this.host = host;
            this.template = template;
            this.FileNameMarker = "generated";
         }

         private Block CurrentBlock
         {
            get { return currentBlock; }
            set
            {
               if (CurrentBlock != null)
                  EndBlock();
               if (value != null)
                  value.Start = template.Length;
               currentBlock = value;
            }
         }

         private class VSManager : Manager
         {
            private readonly EnvDTE.ProjectItem templateProjectItem;
            private readonly EnvDTE.DTE dte;
            private readonly Action<string> checkOutAction;
            private readonly Action<List<string>> projectSyncAction;

            public override string DefaultProjectNamespace
            {
               get { return templateProjectItem.ContainingProject.Properties.Item("DefaultNamespace").Value.ToString(); }
            }

            internal VSManager(ITextTemplatingEngineHost host, StringBuilder template) : base(host, template)
            {
               IServiceProvider hostServiceProvider = (IServiceProvider)host;
               if (hostServiceProvider == null)
                  throw new ArgumentNullException("Could not obtain IServiceProvider");

               dte = (EnvDTE.DTE)hostServiceProvider.GetService(typeof(EnvDTE.DTE));
               if (dte == null)
                  throw new ArgumentNullException("Could not obtain DTE from host");

               templateProjectItem = dte.Solution.FindProjectItem(host.TemplateFile);
               checkOutAction = fileName => dte.SourceControl.CheckOutItem(fileName);
               projectSyncAction = keepFileNames => ProjectSync(keepFileNames);
            }

            public override void Process(bool split)
            {
               if (templateProjectItem.ProjectItems == null)
                  return;

               base.Process(split);
               projectSyncAction.EndInvoke(projectSyncAction.BeginInvoke(generatedFileNames, null, null));
            }

            protected override void CreateFile(string fileName, string content)
            {
               if (IsFileContentDifferent(fileName, content))
               {
                  CheckoutFileIfRequired(fileName);
                  File.WriteAllText(fileName, content);
               }
            }

            private ProjectItem GetOrCreateParentItem(string filePath)
            {
               if (string.IsNullOrEmpty(filePath))
                  return templateProjectItem;

               string projectDirectory = Path.GetDirectoryName(templateProjectItem.ContainingProject.FullName);
               string fileDirectory = Path.GetDirectoryName(filePath);

               if (fileDirectory.ToLower() == projectDirectory.ToLower())
                  return templateProjectItem;

               ProjectItem result = templateProjectItem;

               string relativeFilePath = fileDirectory.Substring(projectDirectory.Length + 1);
               Queue<string> pathParts = new Queue<string>(relativeFilePath.Split('\\'));
               ProjectItems currentItemList = templateProjectItem.ContainingProject.ProjectItems;
               bool found = false;

               while (pathParts.Any())
               {
                  string pathPart = pathParts.Dequeue();

                  for (int index = 1; index <= currentItemList.Count; ++index)
                  {
                     ProjectItem item = currentItemList.Item(index);
                     if (item.Kind == Constants.vsProjectItemKindPhysicalFolder && item.Name == pathPart)
                     {
                        if (!pathParts.Any())
                           result = item;
                        else
                           currentItemList = item.ProjectItems;

                        found = true;
                        break;
                     }
                  }

                  if (!found)
                  {
                     ProjectItem newItem = currentItemList.AddFolder(pathPart);
                     if (!pathParts.Any())
                        result = newItem;
                     else
                        currentItemList = newItem.ProjectItems;
                  }
               }

               return result;
            }

            internal void ProjectSync(IEnumerable<string> keepFileNames)
            {
               Dictionary<ProjectItem, List<string>> current = GetCurrentState();
               Dictionary<ProjectItem, List<string>> target = GetTargetState(keepFileNames);

               Dictionary<ProjectItem, List<string>> add = new Dictionary<ProjectItem, List<string>>();
               foreach (ProjectItem parentItem in target.Keys)
               {
                  IEnumerable<string> additions = target[parentItem].Except(current.ContainsKey(parentItem) ? current[parentItem] : new List<string>());
                  foreach (string addition in additions)
                     parentItem.ProjectItems.AddFromFile(addition);
               }

               Dictionary<ProjectItem, List<string>> remove = new Dictionary<ProjectItem, List<string>>();
               foreach (ProjectItem parentItem in current.Keys)
               {
                  IEnumerable<string> removals = current[parentItem].Except(target.ContainsKey(parentItem) ? target[parentItem] : new List<string>());
                  foreach (string removal in removals)
                     dte.Solution.FindProjectItem(removal).Delete();
               }

               List<string> keepUnderTemplate = (target.ContainsKey(templateProjectItem)
                                                   ? target[templateProjectItem]
                                                   : new List<string>()).Select(s => Path.GetFileName(s)).ToList();
               for (int index = 1; index <= templateProjectItem.ProjectItems.Count; ++index)
               {
                  if (!keepUnderTemplate.Contains(templateProjectItem.ProjectItems.Item(index).Name))
                     templateProjectItem.ProjectItems.Item(index--).Delete();
               }
            }

            private Dictionary<ProjectItem, List<string>> GetTargetState(IEnumerable<string> fileNames)
            {
               Dictionary<ProjectItem, List<string>> result = new Dictionary<ProjectItem, List<string>>();
               result.Add(templateProjectItem, new List<string>());

               foreach (string fileName in fileNames)
               {
                  ProjectItem parentItem = GetOrCreateParentItem(fileName);
                  if (!result.ContainsKey(parentItem))
                     result.Add(parentItem, new List<string>());
                  result[parentItem].Add(fileName);
               }

               return result;
            }

            private Dictionary<ProjectItem, List<string>> GetCurrentState()
            {
               Dictionary<ProjectItem, List<string>> result = new Dictionary<ProjectItem, List<string>>();
               Project currentProject = templateProjectItem.ContainingProject;
               string projectDirectory = Path.GetDirectoryName(currentProject.FullName);
               string[] existingGeneratedFiles = Directory.GetFiles(projectDirectory, $"*.{FileNameMarker}.cs");

               foreach (string fileName in existingGeneratedFiles)
               {
                  ProjectItem fileItem = dte.Solution.FindProjectItem(fileName);
                  if (fileItem != null)
                  {
                     ProjectItem parentItem = (ProjectItem)fileItem.Collection.Parent;
                     if (!result.ContainsKey(parentItem))
                        result.Add(parentItem, new List<string>());
                     result[parentItem].Add(fileName);
                  }
               }

               return result;
            }

            private void CheckoutFileIfRequired(string fileName)
            {
               var sc = dte.SourceControl;
               if (sc != null && sc.IsItemUnderSCC(fileName) && !sc.IsItemCheckedOut(fileName))
                  checkOutAction.EndInvoke(checkOutAction.BeginInvoke(fileName, null, null));
            }
         }
      }

      public class VSIntegration
      {
         // this bit is thanks to Simon Hughes and his EntityFramework Reverse POCO Code First Generator
         // https://github.com/sjh37/EntityFramework-Reverse-POCO-Code-First-Generator
         //
         public IEnumerable<Project> GetAllProjects()
         {
            foreach (Project project in GetSolution().Projects.OfType<Project>())
            {
               if (project.Kind == Constants.vsProjectKindSolutionItems)
                  foreach (Project p in RecurseSolutionFolder(project))
                     yield return p;
               else
                  yield return project;
            }
         }

         public Project GetCurrentProject()
         {
            DTE dte = GetDTE();

            ProjectItem projectItem = dte.Solution.FindProjectItem(Host.TemplateFile);
            if (projectItem != null && projectItem.ContainingProject != null)
               return projectItem.ContainingProject;

            // this returns SELECTED (active) project(s) - it may be a different project than the T4 template. 
            Array activeSolutionProjects = (Array)dte.ActiveSolutionProjects;
            if (activeSolutionProjects == null)
               throw new Exception("DTE.ActiveSolutionProjects returned null");

            if (activeSolutionProjects.Length > 0)
            {
               Project dteProject = (Project)activeSolutionProjects.GetValue(0);
               if (dteProject != null)
                  return dteProject;
            }

            throw new InvalidOperationException("Error in GetCurrentProject(). Unable to find project.");
         }

         public EnvDTE.DTE GetDTE()
         {
            IServiceProvider serviceProvider = (IServiceProvider)Host;
            if (serviceProvider == null)
               throw new Exception("Host property returned unexpected value (null)");

            DTE dte = (DTE)serviceProvider.GetService(typeof(DTE));
            if (dte == null)
               throw new Exception("Unable to retrieve EnvDTE.DTE");

            return dte;
         }

         private string GetProjectPath(Project project)
         {
            string fullProjectName = project.FullName;

            if (string.IsNullOrWhiteSpace(fullProjectName))
               return string.Empty;

            try
            {
               FileInfo info = new FileInfo(fullProjectName);
               return info.Directory != null ? info.Directory.FullName : string.Empty;
            }
            catch
            {
               WriteLine("// Project " + fullProjectName + " excluded.");
               return string.Empty;
            }
         }

         public Solution GetSolution()
         {
            return GetDTE().Solution;
         }

         private IEnumerable<Project> RecurseSolutionFolder(Project project)
         {
            if (project.ProjectItems == null)
               yield break;

            foreach (Project subProject in project.ProjectItems
                                         .Cast<ProjectItem>()
                                         .Select(projectItem => projectItem.SubProject)
                                         .Where(subProject => subProject != null))
            {
               if (subProject.Kind == Constants.vsProjectKindSolutionItems)
                  foreach (Project p in RecurseSolutionFolder(subProject))
                     yield return p;
               else
                  yield return subProject;
            }
         }

         private ProjectItem GetDirectoryItem(string target)
         {
            DTE dte = GetDTE();
            Array projects = dte?.ActiveSolutionProjects as Array;
            Project currentProject = projects?.GetValue(0) as Project;
            ProjectItem targetProjectItem = null;

            if (currentProject != null)
            {
               string rootDirectory = Path.GetDirectoryName(currentProject.FullName);
               Directory.CreateDirectory(Path.Combine(rootDirectory, target));

               Queue<string> paths = new Queue<string>(target.Split('\\'));
               ProjectItems currentItemList = currentProject.ProjectItems;
               bool found = false;

               while (paths.Any())
               {
                  string path = paths.Dequeue();

                  for (int index = 1; index <= currentItemList.Count; ++index)
                  {
                     if (currentItemList.Item(index).Kind == Constants.vsProjectItemKindPhysicalFolder)
                     {
                        if (!paths.Any())
                           targetProjectItem = currentItemList.Item(index);
                        else
                           currentItemList = currentItemList.Item(index).ProjectItems;

                        found = true;
                        break;
                     }
                  }

                  if (!found)
                  {
                     ProjectItem newItem = currentItemList.AddFolder(path);
                     if (!paths.Any())
                        targetProjectItem = newItem;
                     else
                        currentItemList = newItem.ProjectItems;
                  }
               }
            }

            return targetProjectItem;
         }
      }
   }
}